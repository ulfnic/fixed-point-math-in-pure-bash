#!/usr/bin/env bash
# License: GNU Affero General Public License Version 3 (GNU AGPLv3), (c) 2023, Marc Gilligan <marcg@ulfnic.com>


fpm__print_stderr() {
	[[ $2 ]] && printf '%s'"$2" "ERROR: ${0##*/}, " "${@:3}" 1>&2 || :
	return "$1"
}



if (( BASH_VERSINFO[0] < 3 || ( BASH_VERSINFO[0] == 3 && BASH_VERSINFO[1] < 1 ) )); then
	fpm__print_stderr '%s\n' 'BASH version required >= 3.1 (released 2005)' 1>&2
	exit 1
fi



[:() {
	SOLUTION=

	# Inital validation and variable localization
	(( $# > 4 )) && return $(fpm__print_stderr 1 '%s\n' 'too many parameters')
	[[ $4 == ':]' ]] || return $(fpm__print_stderr 1 '%s\n' 'missing trailing ‘:]’')

	local \
		val1=$1 \
		op=$2 \
		val2=$3 \
		precision whole_digits number_re \
		val1_sign val1_leading_zero val1_whole val1_precision val1_whole_len val1_precision_len \
		val2_sign val2_leading_zero val2_whole val2_precision val2_whole_len val2_precision_len \
		op_type


	# Set operator type and Validate
	case $op in
		'+'|'-') op_type='arithmetic' ;;
		'='|'=='|'!='|'>'|'<'|'>='|'<='|'-eq'|'-ne'|'-lt'|'-gt'|'-le'|'-ge') op_type='comparison' ;;
		*) return $(fpm__print_stderr 1 '%s\n' 'unrecognized operator: '"$op") ;;
	esac


	# Validate numbers and divide information into variables
	number_re='^([+-]?)(0?)0*([0-9]*)\.?([0-9]*)$'

	[[ $val1 =~ $number_re ]] || return $(fpm__print_stderr 4 '%s\n' 'NaN value: `'"$val1"'`')
	val1_sign=${BASH_REMATCH[1]}
	val1_leading_zero=${BASH_REMATCH[2]}
	val1_whole=${BASH_REMATCH[3]}
	val1_precision=${BASH_REMATCH[4]}
	val1_whole_len=${#val1_whole}
	val1_precision_len=${#val1_precision}

	[[ $val2 =~ $number_re ]] || return $(fpm__print_stderr 4 '%s\n' 'NaN value: `'"$val2"'`')
	val2_sign=${BASH_REMATCH[1]}
	val2_leading_zero=${BASH_REMATCH[2]}
	val2_whole=${BASH_REMATCH[3]}
	val2_precision=${BASH_REMATCH[4]}
	val2_whole_len=${#val2_whole}
	val2_precision_len=${#val2_precision}


	# Require values have at least one whole or precision digit
	[[ $val1_whole ]] || [[ $val1_precision ]] || [[ $val1_leading_zero ]] || return $(fpm__print_stderr 4 '%s\n' 'NaN value: `'"$val1"'`')
	[[ $val2_whole ]] || [[ $val2_precision ]] || [[ $val2_leading_zero ]] || return $(fpm__print_stderr 4 '%s\n' 'NaN value: `'"$val2"'`')


	# Define the number of digits both whole and precision values will conform to
	(( val1_whole_len > val2_whole_len )) && whole_digits=$val1_whole_len || whole_digits=$val2_whole_len
	(( val1_precision_len > val2_precision_len )) && precision_len=$val1_precision_len || precision_len=$val2_precision_len


	# Normalize whole number and precision character digits for iteration and lexicological comparison
	# Note: %s is used instead of %f to prevent out-of-range errors for numbers that are very large
	printf -v val1 '%*s%s%*s%*s' "$whole_digits" "$val1_whole" "$val1_precision" "$((precision_len - ${#val1_precision}))"
	printf -v val2 '%*s%s%*s%*s' "$whole_digits" "$val2_whole" "$val2_precision" "$((precision_len - ${#val2_precision}))"


	# Switch spaces to zeroes
	val1=${val1// /0}
	val2=${val2// /0}


	fpm__handle_"$op_type" || return $?
}



fpm__format_solution() {
	[[ $solution == 0 ]] && return 0

	[[ $solution ]] && solution=${solution#"${solution%%[!0]*}"}
	[[ $solution ]] || solution=0

	[[ $solution_precision ]] && solution_precision=${solution_precision%"${solution_precision##*[!0]}"}

	if [[ $solution_precision ]]; then
		SOLUTION=$solution_sign$solution'.'$solution_precision
	elif [[ $solution == '0' ]]; then
		SOLUTION=$solution
	else
		SOLUTION=$solution_sign$solution
	fi
}



fpm__handle_arithmetic() {
	local \
		digits_len=$(( whole_digits + precision_len - 1 )) \
		solution_sign solution solution_whole solution_precision temp i num1 num2


	# Normalize arithmetic
	if [[ $val1_sign == '-' ]]; then
		if [[ $val2_sign == '-' ]]; then
			# val1 negative, val2 negative
			if [[ $op == '+' ]]; then 
				solution_sign='-'

			elif [[ $op == '-' ]]; then
				temp=$val1 val1=$val2 val2=$temp
				op='-'
			fi

		else
			# val1 negative, val2 positive
			if [[ $op = '+' ]]; then
				temp=$val1 val1=$val2 val2=$temp
				op='-'

			elif [[ $op = '-' ]]; then
				op='+'
				solution_sign='-'
			fi
		fi
	elif [[ $val2_sign = '-' ]]; then
		# val1 positive, val2 negative
		if [[ $op = '+' ]]; then
			op='-'

		elif [[ $op = '-' ]]; then
			op='+'
		fi
	fi


	if [[ $op == '+' ]]; then
		local carry=0 sum

		for (( i = digits_len; i > -1; i-- )); do
			num1=${val1:$i:1}
			num2=${val2:$i:1}

			sum=$(( num1 + num2 + carry ))
			if (( sum > 9 )); then
				carry=${sum:0:1}
				solution=${sum:1:1}$solution
			else
				carry=0
				solution=$sum$solution
			fi
		done
		[[ $carry == 0 ]] || solution=$carry$solution
		if [[ $precision_len != 0 ]]; then
			solution_precision=${solution: -precision_len}
			solution=${solution:0:-precision_len}
		fi

	elif [[ $op == '-' ]]; then
		local borrow=0

		if [[ $val1 < $val2 ]]; then
			temp=$val1 val1=$val2 val2=$temp
			solution_sign='-'
		fi

		for (( i = digits_len; i > -1; i-- )); do
			num1=${val1:$i:1}; num2=${val2:$i:1}
			(( borrow == 10 )) && (( num1-- )) && borrow=0
			(( num1 < num2 )) && borrow=10
			solution=$(( num1 + borrow - num2 ))$solution
		done

		if [[ $precision_len != 0 ]]; then
			solution_precision=${solution: -precision_len}
			solution=${solution:0:-precision_len}
		fi
	fi


	fpm__format_solution
}



fpm__handle_comparison() {
	# Prefix values with 1 or 0 according to their +/- sign so positive values will be lexicologically higher than negative values
	[[ $val1_sign == '-' ]] && val1='0'$val1 || val1='1'$val1
	[[ $val2_sign == '-' ]] && val2='0'$val2 || val2='1'$val2


	# Normalize operator
	case $op in
		'-eq') op='==';;
		'-ne') op='!=';;
		'-lt') op='<';;
		'-gt') op='>';;
		'-le') op='<=';;
		'-ge') op='>=';;
	esac


	# If both values are negative, normalize val1 val2 parameter order by reversing appropriate operators 
	if [[ $val1_sign == '-' ]] && [[ $val2_sign == '-' ]]; then
		case $op in
			'>') op='<';;
			'<') op='>';;
			'>=') op='<=';;
			'<=') op='>=';;
		esac
	fi


	# Perform lexicological comparison for ==, !=, >= and <= operators
	if [[ $op = '=' ]] || [[ ${op:1:1} == '=' ]]; then
		op=${op:0:1}
		if [[ $val1 == "$val2" ]]; then
			[[ $op == '!' ]] && return 2 || return 0

		else
			[[ $op == '=' ]] && return 2
			[[ $op == '!' ]] && return 0
		fi
	fi


	# Perform lexicological comparison for > and < operators
	if [[ $op == '>' ]]; then
		[[ $val1 > $val2 ]] && return 0 || return 2

	elif [[ $op == '<' ]]; then
		[[ $val1 < $val2 ]] && return 0 || return 2
	fi
}



# If not sourced, pass relevant parts to [: and print solution if any
if [[ ${BASH_SOURCE[0]} == "$0" ]]; then
	if [[ $1 == '-i' ]]; then
		param_arr=($(</dev/stdin))
		[: "${param_arr[@]}" "${@:2}" || exit $?
	else
		[: "$@" || exit $?
	fi

	if [[ $SOLUTION ]]; then
		printf '%s' "$SOLUTION"
		[[ -i ]] && printf '\n'
	fi
	exit 0
fi



